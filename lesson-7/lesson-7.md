# Урок 7. ООП. Продвинутый уровень

* git освоить
* предпоследний урок, будет 2 недели досдать все задания.
* смотрели ли задачники codewars, checkio не забывайте о них, чтобы не забыть python. Хотя бы по задачке в день.

## Домашнее задание

19.09 - ура мое решение :)

Чтобы задать цвет текста в консоли используйте `colorama`, `textcolor`.  
Чтобы использовать графику используем: `takeinter` - растровая графика, `turtle` - графика

```python
class Worker:
    def __init__(self, name, surname, position, income):
        self.name = name
        self.surname = surname
        self.position = position
        self._income = income


class Position(Worker):
    def __init__(self, name, surname, position, income):  # наследуется?
        super().__init__(name, surname, position, income)
```

`\` - символ соединения строк кода

Тема магические методы

1. Перегрузка операторов:
__init__() 
__del__() 
__str__() 
__add__() 
__setattr__() 
__getitem__() 
__call__() 
и др.
2. Переопределение методов.
3. Интерфейсы.
4. Интерфейс итерации.
5. Собственные объекты-итераторы.
6. Декоратор @property.
7. Композиция.
8. Особенности ООП в Python.

## 1. Перегрузка операторов:

Можно сделать что бы автомобильчики складывать или вычитать. Эти имена уже заданы, поэтому мы их просто переопределяем:
* __init__() 
* __del__() при удалении
* __str__() при принт
* __add__() где используется +
* __setattr__() 
* __getitem__() 
* __call__() 
и др.
  
Магические методы сами мы не вызываем, например вместо `__add__` пишем `+`!

```python
class MyClass:
    def __init__(self, p):
        self.p = p
        
    def __del__(self):
        print(f"Deleted object with {self.p}")

my = MyClass(89)
del my  # так обычно не делается, но обычно это делает сборщик мусора, а сборщик мусора разве не удалит
        # да если удалить эту строку, то `Deleted object` все равно будет выведен.
print(my)
```

Магические методы имеют доступ до данных.

Каждый раз когда распечатываю объект, получаю данные о его параметрах. Нужно использовать именно `__str__`, а не свой собственный метод.
```python
class MyClass:
    def __init__(self, p_1, p_2):
        self.p_1 = p_1
        self.p_2 = p_2
        
    def __str__(self):  # без этого будет print не информативен
        return vars(self)

my = MyClass(89, 98)
print(my)
```

Сейчас хочу сложить (перегрузка операторов):
```python
class MyClass:
    def __init__(self, p_1, p_2):
        self.p_1 = p_1
        self.p_2 = p_2
        
    def __add__(self, other):
        # return self.p_1 + other.p_1, self.p_2 + other.p_2  # будут проблемы если сложить a+b+c, a+b=tuple + c = fail
        return MyClass(self.p_1 + other.p_1, self.p_2 + other.p_2)

    def __str__(self):  # без этого будет print не информативен
        return vars(self)

my_1 = MyClass(89, 98)
my_2 = MyClass(90, 80)
print(my_1 + my_1 + my_2)
```

Превратить свой объект в функцию с помощью `__call__`
```python
my("one_attr")
```

В коде не желательно использовать напрямую доступ к атрибутам, используют геттеры и сеттеры.

## 2. Переопределение методов.

обращение к родительскому классу по названию класса или через супер,
обычно родительский по минимуму, а дочерный дописывают

3. Интерфейсы.

Потомок обязан переопределить интерфейс

Декораторы
Функция выполняет что-то одно, и если мы что-то добавим внутри или после функции, то сама логика функции размоется.
Или нужно измерить время выполнения, то дописывая к сотой функции мы запаримся сложнее, чем приписывая к сотой декоратор.
```python
def my_shiny_new_decorator(function_to_decorate):
    # внутри себя функция
    def the_wrapper_around_the_original_function():
        function_to_decorate()
```
Пытался переписать пример, и ничего не понял.

Функция должна отработать

Один пишет методы, которые нужно реализовать, поэтому
```python
from abc import ABC, abstractmethod

class MyOwnABC(ABC):
    @abstractmethod
    def m_1(self):
        pass

new_1 = MyOwnABC() # raised

# потомка не получится с нереализованными создать. Нужно абстрактные методы создать
```

Абстрактный класс можно создать, а вот с абстрактными методами нет. Возможно, тестировать это высказывание не стоит на ABC-helper-е, т.к. его задача просто сделать возможным корректную работу декораторов, таких как абстрактный метод.

```python
class MyClass(ABC):
    pass

my = MyClass()  # можно создать
```

Абстрактные методы нужны для того чтобы их переопределить.

4. Интерфейс итерации.
   
Позволяют доставать следующее значение за контейнера данных. В привязке к итераторам работают циклы `for-in`
Под итераторами понимаются специальные объекты, обеспечивающие пошаговый доступ к данным из контейнера. В привязке к итераторам работают циклы перебора (for in), встроенные функции (map(), filter(), zip()), операция распаковки.

## 5. Собственные объекты-итераторы.

```python
class Iterator:
    def __init__(self, start=0):
        self.i = start

    def __next__(self):
        self.i += 1
        if self.i <= 5:
            return self.i
        else:
            raise StopIteration

class IterObj:
    def __init__(self, start=0):
        self.start = start - 1
    def __iter__(self):
        return Iterator(self.start)

obj = IterObj(start=-2)
for el in obj:
    print(el)
for el in obj: # не истощился
    print(el)
```

Итератор в Python — объект, реализующий метод __next__ без аргументов, возвращающий очередной элемент или исключение StopIteration.
1. Вызов метода __iter__() для итерируемого объекта. Метод __iter__() возвращает объект с методом __next__().
2. Цикл for in во время каждой итерации запускает метод __next__(), который при каждом вызове возвращает очередной элемент итератора.
3. Когда элементы итераторы исчерпаны, метод __next__() завершает свою работу и генерирует исключение StopIteration.


```python
class Iter:
    def __init__(self):
        self.i = 0
    def __iter__(self):
        return self
    def __next__(self):
        self.i += 1
        if self.i <= 5:
            return self.i
        else:
            raise StopIteration  # логика описывается исключением.
```

6. Декоратор @property. 1 час 00

Геттеры и сеттеры нужны для того чтобы пользователи своими данными не ломали нам программу.

```python
@property
def year(self):
    return self.__year

@property.setter
def year(self, year)
```

# 7. Композиция.
   
Композиция сочетание неродственных классов, которые могут находится в отношении композиции. Например, склад хранит объекты оргтехники.
Можем одинаковые методы использовать и если они не потомки, то не переопределится.
Композиция - один класс хранит другой класс

# 8. Особенности ООП в Python.

Класс - это объект, который порождает другие объекты.
Пакет можно инпортировать другие модули.
import request # импорт целой папки

Позволяет структурировать. Защищенные методы работают внутри пакета.
