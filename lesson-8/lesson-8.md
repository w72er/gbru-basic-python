# Урок 8. ООП. Полезные дополнения

## Вопросы

* как узнать какое исключение генерируется?
* pet project приложить можно к портфолио

Напоминания:
* нужно осваивать git
* нарешиваем не десятки, а сотни задач
  * checkio.org
  * codewars.com пояса раздают
  * leetcode.com (после алгоритмов)
Возможно, Есть еще чисто математические задачки на сайте Project Euler, там вывешивают задачи и с повышающимся постепенно уровнем можно на любых языках).

Выкладывайте в git как курсовой проект.

## Домашняя работа

```python
'\n'.join('\t'.join([str(itm) for itm in line]) for line in self.data)
```

## На уроке
1. Статические методы и методы класса.
2. Атрибуты и встроенные методы объектов класса.
3. Пример ООП-программы.
4. Создание собственных исключений.
5. Библиотека psutil.
6. Pip и virtualenv. Особенности использования.
7. Библиотека requests.

## 1. Статические методы и методы класса.

`@staticmethod` Декоратор для метода класса. Такой метод вызывается напрямую через имя класса (статический метод). Не использует self, нужен для придания структуры, что бы недалеко лежал.
```python
class MyClass:
    def m_1(self):  # подчеркивает, что этот метод может быть статическим, т.к. не использует self
        print('Hi')

    @staticmethod
    def m_2(self):
        print('Hi')

my_1 = MyClass()

my_1.m_1()  # Hi
MyClass.m_1()  # ошибка - пропущен self

my_1.m_2()  # Hi
MyClass.m_2()  # Hi
```

47:00

### Отношения обычных методов и статических

* Может ли обычный метод вызывать статический — да, без проблем
* Из статического вызывать обычный — нет, потому что обычный требует self.
  * Создавать новые объекты в статическом методе и вызывать их методы можно `MyClass().m_1()`
  * Есть другой подход, как решать.

`@classmethod` Декоратор для метода класса. Такой метод получает класс в качестве первого аргумента. Он позволяет что-то сделать со всеми объектами класса. Альтернативный инициализатор.

```python
class MyClass:
    def m_1(self):
        self.m_3()  # work
        MyClass.m_3()  # work

    @classmethod
    def m_3(cls):
        print(cls)

my_1 = MyClass()
my_1.m_3()
MyClass.m_3()
```

Метод класса можно вызывать из обычного и статического.
Из метода класса можно вызывать статический, но не обычный.

```python
class MyClass:
    def m_1(self):
        self.m_3()  # work
        MyClass.m_3()  # work
    
    @staticmethod
    def m_2():
        print('m_2')

    @classmethod
    def m_3(cls):
        cls.m_2()
        MyClass.m_2()
        print(cls)

my_1 = MyClass()
my_1.m_3()
MyClass.m_3()
```

### Зачем нужен альтернативный инициализатор?

Альтернативный инициализатор напоминает фабричный метод. Переменная `cls` напомнит выбрать правильное имя класса с помощью интерпретатора, а не программиста.

```python
class MyClass:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    @classmethod
    def set_name(cls, data):
        name, surname = data
        return cls(name, surname)
    
    @staticmethod
    def get_name(self):  #MyClass.get_name(my_2) - работает
        return f'{self.name} {self.surname}'

my_1 = MyClass("Name", "Surname")
print(my_1.name)

my_list = ['J', "Lo"]
my_2 = MyClass.set_name(my_list)
```

## 2. Атрибуты и встроенные методы объектов класса.

Они так же выглядят, как магические методы.

```python
class MyClass:
    """My class"""
    pass

print(MyClass.__name__)  # MyClass
print(MyClass.__module__)  # __main__ т.к. напрямую, а не через импорт. Защита от импорта 
print(MyClass.__doc__)  # документация 
print(MyClass.__init__)  # адрес памяти инициализатора
print(MyClass.__dict__)  # вся информация в одном словаре
```

1:27:25

## 3. Пример ООП-программы.

1. Сформулировать задачу.
2. Определить объекты предметной области, участвующие в решении задачи.
3. Выделить классы, на основе которых генерируются объекты. При необходимости определить базовые классы и классы-потомки.
4. Установить основные атрибуты и методы объектов.
5. Создать классы, их атрибуты и методы.
6. Создать объекты классов.
7. Выполнить итоговое решение задачи, организовав взаимодействие объектов.

1 ...
2. те кто учит, те кто учится, чему учатся.
3. люди: кто учит/учится
4. учить, учиться, предметы просто хранятся.
5. ...

```python
class Teacher():
  def to_teach(self, subj, *pupils):
      for pupil in pupils: pass

teacher.to_teach(subj, p_1, p_2, p_3)
```

Класс склада хранит композицией товары. Оргтехника это не склад (is).

## 4. Создание собственных исключений.

Если стандартных исключений не хватает, то можно свои. Для этого создаем потомок класса Exception.
```python
try:
    res = 1 / 0
except (ZeroDivisionError, TypeError) as err:
    print(err)
else:  # Если не было ошибки
    print(res)
finally:  # всегда даже если вывести `exit(1)`
    print("always")
```

Важен порядок исключений, потому что самый родитель перехватит все.

```python
class MyOwnErr(Exception):
    def __init__(self, txt):
        self.txt = txt

in_data = -1
try:
    if in_data < 0:
        raise MyOwnErr('Only positive')
except MyOwnErr as err:
  print(err)
```

## 5. Библиотека psutil.

Библиотека для получения информации о компюьтере

## 6. Pip и virtualenv. Особенности использования.

Популярная система управления пакетами.

`pip freeze` - отображает список самостоятельно установленных пакетов.
Если хотим кому-то передать версии пакетов, то

```commandline
pip freeze > requirements.txt
```

Виртуальное окружение.
У вас есть несколько проектов, на разных питонах, тогда вам не нужно их приводить все к одной версии питона, или разные версии библиотек.
Зафиксировать версии в проекте поможет виртуальное окружение.
Альтернатива виртуальному окружению докер.

## 7. Библиотека requests.

Как браузер скачивает данные из интернета.
если много сайтов то лучше aiohttp - он работает асинхронно в отличие от синхронного requests
А чтобы из этого всего вырывать данные очень хорошая библиотека есть beautifulsoup)

```python
import requests # error

r = requests.get()
for link in r.text.split('href="')[1:]:
    print(link.split('"')[0])
```